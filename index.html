<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ê–Ω–≥–ª–∏–π—Å–∫–∏–π –≤–∏–¥–µ–æ–ø–ª–µ–µ—Ä</title>
    <style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background: #1a1a1a;
    color: white;
    padding: 20px;
    overflow-x: hidden;
}

.container {
    max-width: 1000px;
    margin: 0 auto;
    position: relative;
}

.video-container {
    position: relative;
    margin-bottom: 20px;
    width: 100%;
}

#videoPlayer {
    width: 100%;
    height: auto;
    border-radius: 10px;
    background: black;
}

/* –°–∫—Ä—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É fullscreen –≤ –Ω–∞—Ç–∏–≤–Ω—ã—Ö –∫–æ–Ω—Ç—Ä–æ–ª–∞—Ö –≤–∏–¥–µ–æ */
video::-webkit-media-controls-fullscreen-button {
    display: none;
}

video::-moz-media-controls-fullscreen-button {
    display: none;
}

/* –ö–û–ù–¢–ï–ô–ù–ï–† –°–£–ë–¢–ò–¢–†–û–í - –û–°–ù–û–í–ù–´–ï –°–¢–ò–õ–ò */
.subtitles-container {
    position: absolute;
    bottom: var(--subtitle-bottom, 80px);
    top: var(--subtitle-top, 20px);
    left: 5%;
    width: 90%;
    background: transparent;
    padding: 0;
    border-radius: 0;
    color: white;
    font-size: var(--subtitle-font-size, 18px);
    line-height: 1.4;
    z-index: 999999;
    pointer-events: none;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
}

/* –†–µ–∂–∏–º –¥–≤—É—Ö –∫–æ–ª–æ–Ω–æ–∫ */
.subtitles-dual-column {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    background: rgba(0, 0, 0, 0.75);
    padding: 10px 15px;
    border-radius: 8px;
}

/* –í fullscreen —Ä–µ–∂–∏–º–µ - –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Ñ–æ–Ω */
.video-container:fullscreen .subtitles-dual-column,
.video-container:-webkit-full-screen .subtitles-dual-column,
.video-container:-moz-full-screen .subtitles-dual-column,
.video-container:-ms-fullscreen .subtitles-dual-column,
body.fullscreen-mode .subtitles-dual-column {
    background: transparent !important;
}

/* –ò—Å—Ç–æ—Ä–∏—è —Å—É–±—Ç–∏—Ç—Ä–æ–≤ - —Å–≤–µ—Ä—Ö—É, –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω–æ */
.subtitles-history {
    margin-bottom: 10px;
}

.subtitles-history-item {
    margin-bottom: 8px;
    opacity: 0.6;
}

.subtitles-history-item .subtitles-dual-column {
    background: transparent;
    font-size: 0.85em;
    padding: 8px 12px;
}

/* –¢–µ–∫—É—â–∏–µ —Å—É–±—Ç–∏—Ç—Ä—ã - —è—Ä—á–µ –∏ –∫—Ä—É–ø–Ω–µ–µ */
.subtitles-current .subtitles-dual-column {
    background: transparent;
    font-size: 1em;
    font-weight: bold;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);
}

.subtitles-english {
    text-align: left;
    padding-right: 10px;
}

.subtitles-russian {
    text-align: left;
    padding-left: 10px;
    border-left: 1px solid rgba(255, 255, 255, 0.3);
}

/* –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–Ω—å –¥–ª—è –ª—É—á—à–µ–π —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏ —Ç–µ–∫—Å—Ç–∞ */
.subtitles-english,
.subtitles-russian {
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9),
                 -1px -1px 2px rgba(0, 0, 0, 0.9),
                 1px -1px 2px rgba(0, 0, 0, 0.9),
                 -1px 1px 2px rgba(0, 0, 0, 0.9);
}

/* –†–µ–∂–∏–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–π */
.subtitles-sequential .english-text {
    margin-bottom: 10px;
}

.subtitles-sequential .russian-text {
    border-top: 1px solid #555;
    padding-top: 10px;
}

/* –°—Ç–∏–ª–∏ –¥–ª—è –æ–¥–∏–Ω–æ—á–Ω—ã—Ö —Å—É–±—Ç–∏—Ç—Ä–æ–≤ */
.subtitles-single {
    text-align: center;
    color: white;
    font-size: var(--subtitle-font-size, 18px);
    line-height: 1.4;
    padding: 10px;
}

/* –≠–ª–µ–º–µ–Ω—Ç—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
.controls {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-bottom: 20px;
    z-index: 1001;
    position: relative;
    align-items: center;
}

button, select {
    padding: 10px 15px;
    border: none;
    border-radius: 5px;
    background: #444;
    color: white;
    cursor: pointer;
}

button:hover {
    background: #555;
}

.status {
    padding: 10px;
    background: #333;
    border-radius: 5px;
    min-height: 40px;
    z-index: 1001;
    position: relative;
}

/* –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è */
.setting-group {
    display: flex;
    align-items: center;
    gap: 5px;
    background: #333;
    padding: 8px 12px;
    border-radius: 5px;
}

.setting-group label {
    font-size: 14px;
    white-space: nowrap;
}

.setting-group input[type="number"] {
    width: 60px;
    padding: 5px;
    border: 1px solid #555;
    border-radius: 3px;
    background: #222;
    color: white;
    text-align: center;
}

.setting-unit {
    font-size: 12px;
    color: #aaa;
}

/* –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Å–ª–æ–≤ */
.highlight-word {
    color: #ff0000;
    font-weight: bold;
}

/* –î–µ–ª–∏—Ç–µ–ª—å –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞ */
.divider {
    height: 1px;
    background: #555;
    margin: 8px 0;
}

/* –ü–û–õ–ù–û–≠–ö–†–ê–ù–ù–´–ô –†–ï–ñ–ò–ú - video-container —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è fullscreen —ç–ª–µ–º–µ–Ω—Ç–æ–º */
.video-container:fullscreen,
.video-container:-webkit-full-screen,
.video-container:-moz-full-screen,
.video-container:-ms-fullscreen {
    width: 100vw !important;
    height: 100vh !important;
    background: black !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    position: relative !important;
}

.video-container:fullscreen #videoPlayer,
.video-container:-webkit-full-screen #videoPlayer,
.video-container:-moz-full-screen #videoPlayer,
.video-container:-ms-fullscreen #videoPlayer {
    width: 100% !important;
    height: 100% !important;
    object-fit: contain !important;
    border-radius: 0 !important;
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
}

.video-container:fullscreen .subtitles-container,
.video-container:-webkit-full-screen .subtitles-container,
.video-container:-moz-full-screen .subtitles-container,
.video-container:-ms-fullscreen .subtitles-container {
    position: absolute !important;
    bottom: var(--subtitle-bottom, 80px) !important;
    top: var(--subtitle-top, 20px) !important;
    left: 5% !important;
    right: 5% !important;
    width: 90% !important;
    max-width: none !important;
    margin: 0 auto !important;
    font-size: var(--subtitle-font-size, 24px) !important;
    line-height: 1.6 !important;
    z-index: 2147483647 !important;
    background: transparent !important;
    color: white !important;
    display: flex !important;
    flex-direction: column !important;
    justify-content: flex-end !important;
    visibility: visible !important;
    opacity: 1 !important;
    pointer-events: none !important;
    padding: 0 !important;
    transform: none !important;
    overflow: hidden !important;
}

/* –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å—Ç–∏–ª–∏ –¥–ª—è fullscreen-mode –∫–ª–∞—Å—Å–∞ (—Ä–µ–∑–µ—Ä–≤–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç) */
body.fullscreen-mode {
    padding: 0;
    background: black;
}

body.fullscreen-mode .container {
    max-width: none;
    width: 100vw;
    height: 100vh;
    margin: 0;
    display: flex;
    flex-direction: column;
}

body.fullscreen-mode .video-container {
    flex: 1;
    margin: 0;
    position: relative;
    background: black;
}

body.fullscreen-mode #videoPlayer {
    width: 100%;
    height: 100%;
    border-radius: 0;
    object-fit: contain;
}

body.fullscreen-mode .subtitles-container {
    position: absolute !important;
    bottom: var(--subtitle-bottom, 80px) !important;
    top: var(--subtitle-top, 20px) !important;
    left: 5% !important;
    right: 5% !important;
    width: 90% !important;
    max-width: none !important;
    font-size: var(--subtitle-font-size, 24px) !important;
    z-index: 2147483647 !important;
    background: transparent !important;
    display: flex !important;
    flex-direction: column !important;
    justify-content: flex-end !important;
    visibility: visible !important;
    opacity: 1 !important;
    padding: 0 !important;
    overflow: hidden !important;
}

body.fullscreen-mode .controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 90%;
    max-width: 1200px;
    background: rgba(0, 0, 0, 0.8);
    padding: 15px;
    border-radius: 10px;
    z-index: 2147483646;
}

body.fullscreen-mode .status {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 90%;
    max-width: 1200px;
    z-index: 2147483646;
}

/* –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö */
@media (max-width: 768px) {
    .subtitles-container {
        font-size: var(--subtitle-font-size, 16px);
        padding: 10px;
    }
    
    .subtitles-dual-column {
        gap: 10px;
        font-size: 14px;
    }
    
    .controls {
        flex-direction: column;
    }
    
    button, select, .setting-group {
        width: 100%;
        margin-bottom: 5px;
    }
    
    /* –ú–æ–±–∏–ª—å–Ω—ã–π –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π —Ä–µ–∂–∏–º */
    .video-container:fullscreen .subtitles-container,
    .video-container:-webkit-full-screen .subtitles-container,
    .video-container:-moz-full-screen .subtitles-container,
    .video-container:-ms-fullscreen .subtitles-container,
    body.fullscreen-mode .subtitles-container {
        font-size: var(--subtitle-font-size, 18px) !important;
    }
    
    body.fullscreen-mode .controls {
        bottom: 10px;
    }
}
    </style>
</head>
<body>
    <div class="container">
        <!-- –í–∏–¥–µ–æ–ø–ª–µ–µ—Ä -->
        <div class="video-container" id="videoContainer">
            <video id="videoPlayer" controls>
                –í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –≤–∏–¥–µ–æ.
            </video>
            <!-- –ö–†–ò–¢–ò–ß–ù–û: –°—É–±—Ç–∏—Ç—Ä—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –í–ù–£–¢–†–ò video-container -->
            <div id="subtitlesContainer" class="subtitles-container"></div>
        </div>

        <!-- –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
        <div class="controls">
            <button id="loadVideoBtn" onclick="loadVideo()" disabled>üìÅ –ó–∞–≥—Ä—É–∑–∏—Ç—å –≤–∏–¥–µ–æ</button>
            <button onclick="loadSubtitles('en')">üìù –ê–Ω–≥–ª. —Å—É–±—Ç–∏—Ç—Ä—ã</button>
            <button onclick="loadSubtitles('ru')">üìù –†—É—Å. —Å—É–±—Ç–∏—Ç—Ä—ã</button>
            <button onclick="loadDictionary()">üìö –ó–∞–≥—Ä—É–∑–∏—Ç—å —Å–ª–æ–≤–∞—Ä—å</button>
            <button onclick="toggleFullscreen()">‚õ∂ –ü–æ–ª–Ω—ã–π —ç–∫—Ä–∞–Ω</button>
            
            <!-- –†–µ–∂–∏–º—ã —Å—É–±—Ç–∏—Ç—Ä–æ–≤ -->
            <select id="subtitleMode" onchange="changeSubtitleMode(this.value)">
                <option value="english-only">–¢–æ–ª—å–∫–æ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π</option>
                <option value="russian-only">–¢–æ–ª—å–∫–æ —Ä—É—Å—Å–∫–∏–π</option>
                <option value="sequential">EN ‚Üí RU –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ</option>
                <option value="dual-column" selected>–î–≤–µ –∫–æ–ª–æ–Ω–∫–∏ EN | RU</option>
            </select>
            
            <!-- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è -->
            <div class="setting-group">
                <label for="fontSizeInput">–®—Ä–∏—Ñ—Ç:</label>
                <input type="number" id="fontSizeInput" min="12" max="48" value="18" onchange="updateFontSize(this.value)">
                <span class="setting-unit">px</span>
            </div>
            
            <div class="setting-group">
                <label for="topOffsetInput">–û—Ç—Å—Ç—É–ø —Å–≤–µ—Ä—Ö—É:</label>
                <input type="number" id="topOffsetInput" min="0" max="200" value="20" onchange="updateTopOffset(this.value)">
                <span class="setting-unit">px</span>
            </div>
            
            <div class="setting-group">
                <label for="bottomOffsetInput">–û—Ç—Å—Ç—É–ø —Å–Ω–∏–∑—É:</label>
                <input type="number" id="bottomOffsetInput" min="0" max="300" value="80" onchange="updateBottomOffset(this.value)">
                <span class="setting-unit">px</span>
            </div>
        </div>

        <!-- –°—Ç–∞—Ç—É—Å -->
        <div id="status" class="status"></div>
    </div>

    <!-- –°–∫—Ä—ã—Ç—ã–µ input'—ã –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–æ–≤ -->
    <input type="file" id="videoFile" accept="video/*" style="display: none">
    <input type="file" id="enSubtitleFile" style="display: none">
    <input type="file" id="ruSubtitleFile" style="display: none">
    <input type="file" id="dictionaryFile" style="display: none">

    <script>
// ========== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ==========
let videoPlayer;
let subtitlesContainer;
let englishSubtitles = [];
let russianSubtitles = [];
let syncedSubtitles = [];
let currentSubtitleMode = 'dual-column';
let subtitleInterval;
let subtitleHistory = [];
let currentSubtitleIndex = -1;

// –°–ª–æ–≤–∞—Ä—å –¥–ª—è –ø–æ–¥—Å–≤–µ—Ç–∫–∏
let wordDictionary = {};
let wordSet = new Set();
let highlightRegex = null;
let isDictionaryLoaded = false;

// –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
let currentFontSize = 18;
let currentTopOffset = 20;
let currentBottomOffset = 80;

// ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ==========
document.addEventListener('DOMContentLoaded', function() {
    videoPlayer = document.getElementById('videoPlayer');
    subtitlesContainer = document.getElementById('subtitlesContainer');
    updateStatus('‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞ —Å–ª–æ–≤–∞—Ä—è —Å —Å–µ—Ä–≤–µ—Ä–∞...');
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è CSS –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
    updateCSSVariables();
    
    videoPlayer.addEventListener('error', function(e) {
        updateStatus('–û—à–∏–±–∫–∞ –≤–∏–¥–µ–æ: ' + getVideoError(videoPlayer.error));
    });
    
    // –ê–≤—Ç–æ–∑–∞–≥—Ä—É–∑–∫–∞ —Å–ª–æ–≤–∞—Ä—è —Å GitHub
    loadDictionaryAuto();
});

// ========== –û–ë–ù–û–í–õ–ï–ù–ò–ï CSS –ü–ï–†–ï–ú–ï–ù–ù–´–• ==========
function updateCSSVariables() {
    document.documentElement.style.setProperty('--subtitle-font-size', currentFontSize + 'px');
    document.documentElement.style.setProperty('--subtitle-top', currentTopOffset + 'px');
    document.documentElement.style.setProperty('--subtitle-bottom', currentBottomOffset + 'px');
}

// ========== –§–£–ù–ö–¶–ò–ò –ù–ê–°–¢–†–û–ô–ö–ò –û–¢–û–ë–†–ê–ñ–ï–ù–ò–Ø ==========
function updateFontSize(value) {
    currentFontSize = parseInt(value) || 18;
    updateCSSVariables();
    showSubtitlesAtTime(videoPlayer.currentTime);
}

function updateTopOffset(value) {
    currentTopOffset = parseInt(value) || 20;
    updateCSSVariables();
}

function updateBottomOffset(value) {
    currentBottomOffset = parseInt(value) || 80;
    updateCSSVariables();
}

// ========== –ü–û–°–¢–†–û–ï–ù–ò–ï –ò–ù–î–ï–ö–°–ê –°–õ–û–í ==========
function buildWordIndex() {
    wordSet.clear();
    const allWords = [];
    
    for (const [baseWord, forms] of Object.entries(wordDictionary)) {
        forms.forEach(form => {
            const normalized = form.toLowerCase();
            wordSet.add(normalized);
            allWords.push(normalized);
        });
    }
    
    allWords.sort((a, b) => b.length - a.length);
    const escapedWords = allWords.map(w => w.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
    const pattern = '\\b(' + escapedWords.join('|') + ')\\b';
    highlightRegex = new RegExp(pattern, 'gi');
    
    console.log('–°–æ–∑–¥–∞–Ω –∏–Ω–¥–µ–∫—Å:', wordSet.size, '—Ñ–æ—Ä–º —Å–ª–æ–≤');
}

// ========== –ê–í–¢–û–ó–ê–ì–†–£–ó–ö–ê –°–õ–û–í–ê–†–Ø –° GITHUB ==========
function loadDictionaryAuto() {
    fetch('dictionary.json')
        .then(response => {
            if (!response.ok) {
                throw new Error('–°–ª–æ–≤–∞—Ä—å –Ω–µ –Ω–∞–π–¥–µ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ (HTTP ' + response.status + ')');
            }
            return response.json();
        })
        .then(data => {
            wordDictionary = data;
            buildWordIndex();
            isDictionaryLoaded = true;
            
            // –†–∞–∑–±–ª–æ–∫–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫—É –∑–∞–≥—Ä—É–∑–∫–∏ –≤–∏–¥–µ–æ
            const videoBtn = document.getElementById('loadVideoBtn');
            if (videoBtn) {
                videoBtn.disabled = false;
            }
            
            updateStatus(`‚úÖ –°–ª–æ–≤–∞—Ä—å –∑–∞–≥—Ä—É–∂–µ–Ω —Å —Å–µ—Ä–≤–µ—Ä–∞: ${Object.keys(wordDictionary).length} —Å–ª–æ–≤, ${wordSet.size} —Ñ–æ—Ä–º`);
            console.log('‚úÖ –°–ª–æ–≤–∞—Ä—å —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω —Å GitHub');
        })
        .catch(error => {
            isDictionaryLoaded = false;
            updateStatus(`‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–ª–æ–≤–∞—Ä—è: ${error.message}. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É "–ó–∞–≥—Ä—É–∑–∏—Ç—å —Å–ª–æ–≤–∞—Ä—å" –¥–ª—è —Ä—É—á–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏.`);
            console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–ª–æ–≤–∞—Ä—è:', error);
        });
}

// ========== –ó–ê–ì–†–£–ó–ö–ê –°–õ–û–í–ê–†–Ø –í–†–£–ß–ù–£–Æ (–ó–ê–ü–ê–°–ù–û–ô –í–ê–†–ò–ê–ù–¢) ==========
function loadDictionary() {
    document.getElementById('dictionaryFile').click();
}

document.getElementById('dictionaryFile').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (file) {
        updateStatus('‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞ —Å–ª–æ–≤–∞—Ä—è –∏–∑ —Ñ–∞–π–ª–∞...');
        
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                wordDictionary = JSON.parse(e.target.result);
                buildWordIndex();
                isDictionaryLoaded = true;
                
                // –†–∞–∑–±–ª–æ–∫–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫—É –∑–∞–≥—Ä—É–∑–∫–∏ –≤–∏–¥–µ–æ
                const videoBtn = document.getElementById('loadVideoBtn');
                if (videoBtn) {
                    videoBtn.disabled = false;
                }
                
                updateStatus(`‚úÖ –°–ª–æ–≤–∞—Ä—å –∑–∞–≥—Ä—É–∂–µ–Ω –∏–∑ —Ñ–∞–π–ª–∞: ${Object.keys(wordDictionary).length} —Å–ª–æ–≤, ${wordSet.size} —Ñ–æ—Ä–º`);
                
                if (videoPlayer.currentTime > 0) {
                    showSubtitlesAtTime(videoPlayer.currentTime);
                }
            } catch (error) {
                isDictionaryLoaded = false;
                updateStatus('‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ —Ñ–∞–π–ª–∞: ' + error.message);
            }
        };
        reader.onerror = function() {
            isDictionaryLoaded = false;
            updateStatus('‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞');
        };
        reader.readAsText(file, 'UTF-8');
    }
});

// ========== –ó–ê–ì–†–£–ó–ö–ê –í–ò–î–ï–û ==========
function loadVideo() {
    if (!isDictionaryLoaded) {
        alert('–°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ —Å–ª–æ–≤–∞—Ä—å!');
        return;
    }
    document.getElementById('videoFile').click();
}

document.getElementById('videoFile').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (file) {
        if (!file.type.startsWith('video/')) {
            updateStatus('–û—à–∏–±–∫–∞: –≤—ã–±–µ—Ä–∏—Ç–µ –≤–∏–¥–µ–æ—Ñ–∞–π–ª');
            return;
        }
        
        if (subtitleInterval) {
            clearInterval(subtitleInterval);
        }
        
        const videoURL = URL.createObjectURL(file);
        videoPlayer.src = videoURL;
        updateStatus(`–í–∏–¥–µ–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ: ${file.name}`);
        
        subtitlesContainer.innerHTML = '';
        englishSubtitles = [];
        russianSubtitles = [];
        syncedSubtitles = [];
        subtitleHistory = [];
    }
});

// ========== –ó–ê–ì–†–£–ó–ö–ê –°–£–ë–¢–ò–¢–†–û–í ==========
function loadSubtitles(lang) {
    const fileInput = lang === 'en' ? 'enSubtitleFile' : 'ruSubtitleFile';
    document.getElementById(fileInput).click();
}

document.getElementById('enSubtitleFile').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (file) parseSubtitles(file, 'en');
});

document.getElementById('ruSubtitleFile').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (file) parseSubtitles(file, 'ru');
});

function parseSubtitles(file, lang) {
    const reader = new FileReader();
    
    reader.onload = function(e) {
        try {
            let text = e.target.result;
            if (text.charCodeAt(0) === 0xFEFF) {
                text = text.substring(1);
            }
            
            const subtitles = parseSRT(text);
            
            if (lang === 'en') {
                englishSubtitles = subtitles;
                updateStatus(`–ê–Ω–≥–ª–∏–π—Å–∫–∏–µ —Å—É–±—Ç–∏—Ç—Ä—ã: ${subtitles.length} —Ñ—Ä–∞–∑`);
            } else {
                russianSubtitles = subtitles;
                updateStatus(`–†—É—Å—Å–∫–∏–µ —Å—É–±—Ç–∏—Ç—Ä—ã: ${subtitles.length} —Ñ—Ä–∞–∑`);
            }
            
            if (englishSubtitles.length > 0 && russianSubtitles.length > 0) {
                syncSubtitles();
            }
            
            if (videoPlayer.src) {
                startSubtitleTracking();
                showSubtitlesAtTime(videoPlayer.currentTime);
            }
        } catch (error) {
            updateStatus('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞: ' + error.message);
        }
    };
    
    reader.readAsText(file, 'UTF-8');
}

function parseSRT(data) {
    const subtitles = [];
    const normalizedData = data.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    const blocks = normalizedData.split('\n\n');
    
    for (const block of blocks) {
        if (block.trim() === '') continue;
        
        const lines = block.split('\n').filter(line => line.trim() !== '');
        if (lines.length < 3) continue;
        
        let timeLineIndex = -1;
        for (let i = 0; i < Math.min(3, lines.length); i++) {
            if (lines[i].includes('-->')) {
                timeLineIndex = i;
                break;
            }
        }
        
        if (timeLineIndex === -1) continue;
        
        const timeMatch = lines[timeLineIndex].match(/(\d+):(\d+):(\d+)[,.](\d+)\s*-->\s*(\d+):(\d+):(\d+)[,.](\d+)/);
        if (!timeMatch) continue;
        
        const startTime = timeToSeconds(timeMatch[1], timeMatch[2], timeMatch[3], timeMatch[4]);
        const endTime = timeToSeconds(timeMatch[5], timeMatch[6], timeMatch[7], timeMatch[8]);
        
        const textLines = lines.slice(timeLineIndex + 1);
        const text = textLines.join(' ').trim();
        
        if (text) {
            subtitles.push({ start: startTime, end: endTime, text: text });
        }
    }
    
    subtitles.sort((a, b) => a.start - b.start);
    return subtitles;
}

function timeToSeconds(hours, minutes, seconds, milliseconds) {
    let ms = parseInt(milliseconds);
    if (milliseconds.length === 2) ms = ms * 10;
    else if (milliseconds.length === 1) ms = ms * 100;
    
    return parseInt(hours) * 3600 + parseInt(minutes) * 60 + parseInt(seconds) + ms / 1000;
}

// ========== –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–Ø –°–£–ë–¢–ò–¢–†–û–í ==========
function syncSubtitles() {
    syncedSubtitles = [];
    const usedRussianIndexes = new Set();
    
    for (let i = 0; i < englishSubtitles.length; i++) {
        const enSub = englishSubtitles[i];
        let bestMatch = null;
        let bestMatchIndex = -1;
        let maxOverlap = 0;
        
        for (let j = 0; j < russianSubtitles.length; j++) {
            if (usedRussianIndexes.has(j)) continue;
            
            const ruSub = russianSubtitles[j];
            const overlapStart = Math.max(enSub.start, ruSub.start);
            const overlapEnd = Math.min(enSub.end, ruSub.end);
            const overlap = Math.max(0, overlapEnd - overlapStart);
            const timeDiff = Math.abs(enSub.start - ruSub.start);
            
            if (overlap > 0 || timeDiff < 3) {
                const score = overlap - timeDiff * 0.1;
                if (score > maxOverlap) {
                    maxOverlap = score;
                    bestMatch = ruSub;
                    bestMatchIndex = j;
                }
            }
        }
        
        if (bestMatchIndex !== -1) {
            usedRussianIndexes.add(bestMatchIndex);
        }
        
        syncedSubtitles.push({
            index: i,
            en: enSub.text,
            ru: bestMatch ? bestMatch.text : '',
            start: Math.min(enSub.start, bestMatch ? bestMatch.start : enSub.start),
            end: Math.max(enSub.end, bestMatch ? bestMatch.end : enSub.end)
        });
    }
    
    updateStatus(`–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–æ ${syncedSubtitles.length} –ø–∞—Ä`);
}

// ========== –û–¢–°–õ–ï–ñ–ò–í–ê–ù–ò–ï –°–£–ë–¢–ò–¢–†–û–í ==========
function startSubtitleTracking() {
    if (subtitleInterval) clearInterval(subtitleInterval);
    
    subtitleInterval = setInterval(() => {
        if (!videoPlayer.paused && !videoPlayer.ended) {
            showSubtitlesAtTime(videoPlayer.currentTime);
        }
    }, 100);
}

function showSubtitlesAtTime(currentTime) {
    if (syncedSubtitles.length === 0) {
        const enSub = findSubtitleAtTime(englishSubtitles, currentTime);
        const ruSub = findSubtitleAtTime(russianSubtitles, currentTime);
        renderSubtitles(enSub, ruSub);
        return;
    }
    
    let foundIndex = -1;
    for (let i = 0; i < syncedSubtitles.length; i++) {
        const pair = syncedSubtitles[i];
        if (currentTime >= pair.start - 0.1 && currentTime <= pair.end + 0.1) {
            foundIndex = i;
            break;
        }
    }
    
    if (foundIndex !== -1 && foundIndex !== currentSubtitleIndex && currentSubtitleMode === 'dual-column') {
        currentSubtitleIndex = foundIndex;
        subtitleHistory.push(foundIndex);
        
        if (subtitleHistory.length > 10) {
            subtitleHistory.shift();
        }
    } else if (foundIndex === -1) {
        currentSubtitleIndex = -1;
    }
    
    const currentPair = foundIndex !== -1 ? syncedSubtitles[foundIndex] : null;
    renderSubtitlesFromPair(currentPair);
}

function findSubtitleAtTime(subtitles, time) {
    if (!subtitles || subtitles.length === 0) return null;
    
    for (const sub of subtitles) {
        if (time >= sub.start - 0.1 && time <= sub.end + 0.1) {
            return sub;
        }
    }
    return null;
}

// ========== –†–ï–ù–î–ï–† –°–£–ë–¢–ò–¢–†–û–í ==========
function renderSubtitlesFromPair(currentPair) {
    if (!currentPair && currentSubtitleMode !== 'dual-column') {
        subtitlesContainer.innerHTML = '';
        return;
    }
    
    let html = '';
    
    switch(currentSubtitleMode) {
        case 'english-only':
            html = currentPair ? `<div class="subtitles-single">${highlightWords(currentPair.en)}</div>` : '';
            break;
            
        case 'russian-only':
            html = currentPair ? `<div class="subtitles-single">${currentPair.ru}</div>` : '';
            break;
            
        case 'sequential':
            if (currentPair) {
                html = `
                    <div class="subtitles-sequential">
                        ${currentPair.en ? `<div class="english-text">${highlightWords(currentPair.en)}</div>` : ''}
                        ${currentPair.en && currentPair.ru ? '<div class="divider"></div>' : ''}
                        ${currentPair.ru ? `<div class="russian-text">${currentPair.ru}</div>` : ''}
                    </div>
                `;
            }
            break;
            
        case 'dual-column':
        default:
            let historyHtml = '';
            if (subtitleHistory.length > 0) {
                historyHtml = '<div class="subtitles-history">';
                const historyToShow = currentPair ? subtitleHistory.slice(0, -1) : subtitleHistory;
                
                historyToShow.forEach(pairIndex => {
                    const pair = syncedSubtitles[pairIndex];
                    if (pair) {
                        historyHtml += `
                            <div class="subtitles-history-item">
                                <div class="subtitles-dual-column">
                                    <div class="subtitles-english">${pair.en ? highlightWords(pair.en) : ''}</div>
                                    <div class="subtitles-russian">${pair.ru ? pair.ru : ''}</div>
                                </div>
                            </div>
                        `;
                    }
                });
                historyHtml += '</div>';
            }
            
            const currentHtml = currentPair ? `
                <div class="subtitles-current">
                    <div class="subtitles-dual-column">
                        <div class="subtitles-english">${currentPair.en ? highlightWords(currentPair.en) : ''}</div>
                        <div class="subtitles-russian">${currentPair.ru ? currentPair.ru : ''}</div>
                    </div>
                </div>
            ` : '';
            
            html = historyHtml + currentHtml;
            break;
    }
    
    subtitlesContainer.innerHTML = html;
    
    const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || 
                           document.mozFullScreenElement || document.msFullscreenElement);
    
    if (isFullscreen && subtitlesContainer && html) {
        subtitlesContainer.style.display = 'flex';
        subtitlesContainer.style.visibility = 'visible';
        subtitlesContainer.style.opacity = '1';
    }
}

function renderSubtitles(enSub, ruSub) {
    const enText = enSub ? enSub.text : '';
    const ruText = ruSub ? ruSub.text : '';
    
    if (!enText && !ruText) {
        subtitlesContainer.innerHTML = '';
        return;
    }
    
    let html = '';
    
    switch(currentSubtitleMode) {
        case 'english-only':
            html = `<div class="subtitles-single">${highlightWords(enText)}</div>`;
            break;
        case 'russian-only':
            html = `<div class="subtitles-single">${ruText}</div>`;
            break;
        default:
            html = `
                <div class="subtitles-dual-column">
                    <div class="subtitles-english">${enText ? highlightWords(enText) : ''}</div>
                    <div class="subtitles-russian">${ruText ? ruText : ''}</div>
                </div>
            `;
    }
    
    subtitlesContainer.innerHTML = html;
}

// ========== –ü–û–î–°–í–ï–¢–ö–ê –°–õ–û–í ==========
function highlightWords(text) {
    if (!text || !highlightRegex) return text;
    
    return text.replace(highlightRegex, match => {
        return `<span class="highlight-word">${match}</span>`;
    });
}

// ========== –£–ü–†–ê–í–õ–ï–ù–ò–ï –†–ï–ñ–ò–ú–ê–ú–ò ==========
function changeSubtitleMode(mode) {
    currentSubtitleMode = mode;
    subtitleHistory = [];
    currentSubtitleIndex = -1;
    showSubtitlesAtTime(videoPlayer.currentTime);
}

// ========== –ü–û–õ–ù–û–≠–ö–†–ê–ù–ù–´–ô –†–ï–ñ–ò–ú ==========
function toggleFullscreen() {
    const container = document.getElementById('videoContainer');
    if (!container) return;
    
    if (!document.fullscreenElement) {
        const requestFullscreen = container.requestFullscreen || 
                                 container.webkitRequestFullscreen || 
                                 container.mozRequestFullScreen || 
                                 container.msRequestFullscreen;
        
        if (requestFullscreen) {
            requestFullscreen.call(container).then(() => {
                document.body.classList.add('fullscreen-mode');
                
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        showSubtitlesAtTime(videoPlayer.currentTime);
                        if (subtitlesContainer) {
                            subtitlesContainer.style.display = 'flex';
                            subtitlesContainer.style.visibility = 'visible';
                            subtitlesContainer.style.opacity = '1';
                        }
                    }, i * 200);
                }
            }).catch(err => {
                updateStatus('–û—à–∏–±–∫–∞ fullscreen: ' + err.message);
            });
        }
    } else {
        const exitFullscreen = document.exitFullscreen || 
                              document.webkitExitFullscreen || 
                              document.mozCancelFullScreen || 
                              document.msExitFullscreen;
        
        if (exitFullscreen) {
            exitFullscreen.call(document).then(() => {
                document.body.classList.remove('fullscreen-mode');
            });
        }
    }
}

document.addEventListener('fullscreenchange', handleFullscreenChange);
document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
document.addEventListener('mozfullscreenchange', handleFullscreenChange);
document.addEventListener('MSFullscreenChange', handleFullscreenChange);

function handleFullscreenChange() {
    const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || 
                           document.mozFullScreenElement || document.msFullscreenElement);
    
    if (isFullscreen) {
        document.body.classList.add('fullscreen-mode');
    } else {
        document.body.classList.remove('fullscreen-mode');
    }
    
    for (let i = 0; i < 10; i++) {
        setTimeout(() => {
            showSubtitlesAtTime(videoPlayer.currentTime);
            if (subtitlesContainer) {
                subtitlesContainer.style.display = 'flex';
                subtitlesContainer.style.visibility = 'visible';
                subtitlesContainer.style.opacity = '1';
            }
        }, i * 100);
    }
}

// ========== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ==========
function updateStatus(message) {
    const statusEl = document.getElementById('status');
    if (statusEl) {
        statusEl.textContent = message;
    }
    console.log('Status:', message);
}

function getVideoError(error) {
    if (!error) return '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞';
    switch (error.code) {
        case error.MEDIA_ERR_ABORTED: return '–í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –ø—Ä–µ—Ä–≤–∞–Ω–æ';
        case error.MEDIA_ERR_NETWORK: return '–û—à–∏–±–∫–∞ —Å–µ—Ç–∏';
        case error.MEDIA_ERR_DECODE: return '–û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è';
        case error.MEDIA_ERR_SRC_NOT_SUPPORTED: return '–§–æ—Ä–º–∞—Ç –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è';
        default: return '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞';
    }
}

// ========== –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô –í–ò–î–ï–û ==========
videoPlayer.addEventListener('ended', function() {
    if (subtitleInterval) clearInterval(subtitleInterval);
    subtitlesContainer.innerHTML = '';
    subtitleHistory = [];
    currentSubtitleIndex = -1;
});

videoPlayer.addEventListener('play', function() {
    if (englishSubtitles.length > 0 || russianSubtitles.length > 0) {
        startSubtitleTracking();
    }
});

videoPlayer.addEventListener('seeked', function() {
    subtitleHistory = [];
    currentSubtitleIndex = -1;
    showSubtitlesAtTime(videoPlayer.currentTime);
});
    </script>
</body>
</html>
